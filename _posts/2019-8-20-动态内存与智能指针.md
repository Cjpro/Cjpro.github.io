---
layout:     post
title:      C++动态内存和智能指针
subtitle:   初探new,delete,shared_ptr
date:       2019-08-20
author:     Cory
header-img: img/post-bg-shardptr.jpg
catalog: true
tags:
    - C++
---
#C++动态内存

了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：

- 栈：在函数内部声明的所有变量都将占用栈内存。
- 堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。
很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。

在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。

如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。
#new和delete运算符
```
new data-type
```
在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点：
```
double* pvalue  = NULL; // 初始化为 null 的指针
pvalue  = new double;   // 为变量请求内存
```
malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。

在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：
```
delete pvalue;        // 释放 pvalue 所指向的内存
```
##new和malloc有什么不同

new 的功能是在堆区新建一个对象，并返回该对象的指针。所谓的【新建对象】的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。而 malloc 只是机械的分配一块内存，如果用 mallco 在堆区创建一个对象的话，是不会调用构造函数的。严格说来用 malloc 不能算是新建了一个对象，只能说是分配了一块与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，按这个逻辑来，也不存在构造函数什么事。同样的，用 delete 去释放一个堆区的对象，会调用该对象的析构函数。用 free 去释放一个堆区的对象，不会调用该对象的析构函数。
做个简单的实验即可明了:
```
#include <iostream>
#include <malloc.h>

class TEST
{
private:
    int num1;
    int num2;
public:
    TEST()
    {
        num1 = 10;
        num2 = 20;
    }
    void Print()
    {
        std::cout << num1 << " " << num2 << std::endl;
    }
};

int main(void)
{
    // 用malloc()函数在堆区分配一块内存空间，然后用强制类型转换将该块内存空间
    // 解释为是一个TEST类对象，这不会调用TEST的默认构造函数
    TEST * pObj1 = (TEST *)malloc(sizeof(TEST));
    pObj1->Print();

    // 用new在堆区创建一个TEST类的对象，这会调用TEST类的默认构造函数
    TEST * pObj2 = new TEST;
    pObj2->Print();

    return 0;
}
/*
运行结果：

-----------------------------
-842150451 -842150451       |
10 20                       |
请按任意键继续. . .         |
-----------------------------

我们可以看到pObj1所指的对象中，字段num1与num2都是垃圾值
而pObj2所指的对象中，字段num1与num2显然是经过了构造后的值
*/
```
#智能指针

动态内存的使用很容易出现问题，因为确保在正确的时间释放内存是极其困难的。有时候我们会忘记释放内存，在这种情况下就会产生内存泄漏；有时候在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存的指针。

 为了更容易地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。
 
##shred_ptr类

类似vector，智能指针也是模板。因此当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种智能指针的名字：
```
shared_ptr<string> p1;        //shared_ptr,可以指向string
shared_ptr<list<int>> p2;     //shard_ptr,可以指向int的list
```
默认初始化的智能指针中保存着一个空指针。
智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：
```
if(p1 && p1->empty())    //如果p1不为空，检查它是否指向一个空string
  *p1 = "hi";            //若果p1指向一个空string，解引用p1，将一个新值赋予string
```

|shared_ptr和unique_ptr|都支持的操作|
|:-:|:-:|
|shared_ptr<T> sp|空智能指针，可以指向类型为T的对象|
|unique_ptr<T> up||
|p|将p用作一个条件判断，若p指向一个对象，则为true|
|*p|解引用p，获得它所指的对象|
|p->|等价于(*p).mem|
|p.get()|返回p中所保存的指针.要小心,若智能指针释放了其对象,返回的指针所指向的对象也就消失了|
|swap(p,q)|交换p和q中的指针|
|p.swap(q)||

