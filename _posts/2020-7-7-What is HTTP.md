---
layout:     post
title:      HTTP总结
subtitle:   详解HTTP及常见问题
date:       2020-07-07
author:     Cory
header-img: img/bg-pen.jpg
catalog: true
tags:
    - 网络
    - HTTP
---





1989年，蒂姆·伯纳斯 - 李（Tim Berners-Lee）在论文中提出可以在互联网上构建超链接文档，并提出了三点.

- URI：统一资源标识符。互联网的唯一ID

- HTML：超文本文档

- HTTP:传输超文本的文本传输协议



## 1 What is HTTP

HTTP(hypertext transport protocol)翻译过来为<font color="#dd0000">“超文本传输协议”</font> ，文本可以理解为简单的字符文字组合，也可以理解为更为复杂的音频或者图像等。那么将这个词语拆分为三个部分。

<font color="#dd0000">“超文本”</font>和<font color="#dd0000">“文本”</font>相比多了一个字"超"，这样看来比文本丰富，因为它可以将多种文本/图像等进行混合，更重要的是可以从一个文本跳转到另一个文本(文本连接)。

<font color="#dd0000">“传输”</font>的过程中需要沟通，沟通即可能一对一沟通也可能一对多沟通(进行内容协商)，无论怎么样，参加沟通的人数>1，想尽一切一切办法更快更好的完成相应的任务。

<font color="#dd0000">“协议”</font>，无规矩不成方圆，做机密项目之前需要签署保密协议，找工作要签"三方协议"，三方协议是学校，公司，和个人组成的协议，都是为了让大家受一定的约束，违反了即有相应的惩罚。



## 2 HTTP的不同版本

<font color="#dd0000">HTTP/0.9</font>

当时网络资源匮乏，0.9版本相对简单，采用纯文本格式，且设置为只读，所以当时只能使用"Get"的方式从服务器获得HTML文档，响应以后则关闭。如下:

```http
GET /corycj.html
```

响应中只包含了文档本身。响应内容无响应头，无错误码，无状态码，可以说是"裸奔"。

```html
<HTML>
Hello world
</HTML>
HTTP/0.9
```

此时 <font color="#dd0000">HTTP/0.9</font> 请求过程如下:

- 应用层的HTTP建立在传输层的TCP之上并运用TCP可靠性等特性，先三次握手建立连接
- 客户端请求建立连接(此时只有GET)
- 服务端响应请求，数据以 ASCII 字符流返回给客戶端
- 传输完成，断开连接。

![](https://i.loli.net/2020/07/05/Rbm7OfzH5oidNTQ.png)



<font color="#dd0000">HTTP/1.0</font>

随着时代的进步，仅仅文本的传输无法满足需求，更多情况需要采用图文的方式才能生动的表达出自己的观点。随着1995年开发出Apache，同时其他的多媒体等技术发展迅速，从而进一步的促使HTTP新功能的出现。HTTP1.0在1996年诞生，增加了一下几个方面：

- 之前只有Get方法，现在增加Post(加参数)，Head方法

- 加入协议版本号，同时添加文件处理类型

- 加入HTTP Header，让HTTP处理请求更加灵活

- 增加响应状态码，标记出错的原因

- 提供国际化(不同语言)支持

  

<font color="#0000dd">典型的请求过程</font> 

```http
GET /image.html HTTP/1.0
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)

200 OK
Date: Tue, 17 Nov 2020 09:15:31 GMT
Content-Type: text/html
<HTML> 
一个包含图片的页面
  <IMG SRC="/image.gif">
</HTML>
```

![http1.0](https://i.loli.net/2020/07/05/nkTNI8PmdcKXwSa.png)



<font color="#dd0000">HTTP/1.1</font>

1995年是不平凡的一年，网景公司和微软开启浏览器大战，谁都想当老大。1999年HTTP/1.1发布并成为标准，写入RFC，以为以后不管是网关还是APP等，只要你要使用HTTP，就得遵守这个标准。

- 继续增加了PUT等方法
- 允许持久连接(keep-alive)

随着文件越来越大，图片等信息越来越复杂，如果每一次上传下载文件都需要建立连接断开连接的过程将增加大量的开销。为此，提出了<font color="#dd0000">持久连接</font>，也就是一次TCP连接可以具有多个HTTP请求。当然持久连接是可选择的，如果考虑关闭，只需要使用<font color="#dd0000">Connection:close</font>关闭即可。长连接如下图所示

![](https://i.loli.net/2020/07/05/h5jcWCo62ui1JPb.png)



<font color="#dd0000">HTTP/2.0的特点</font>

HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。

任何事物的更新都是为了弥补或修复上个版本的某些问题，那么我们来看看HTTP1.x都有哪些缺点以至于我们要使用HTTP2.0。

HTTP1.x有以下几个主要缺点：

1. HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
2. 单向请求，只能由客户端发起。
3. 请求报文与响应报文首部信息冗余量大。
4. 数据未压缩，导致数据的传输量大。



### 二进制传输



HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。
在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。



### 多路复用

在HTTP1.0中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。
HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。
帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。

### Header压缩

在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。
在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。



### 服务器Push

在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。
可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。



### 更安全

HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。



### 额外补充：QUIC[1]

这里额外给大家介绍一个协议，是由Google基于UDP实现的同为传输层的协议，目标是希望替代TCP协议。
该协议支持多路复用，虽然说HTTP2.0也支持多路复用，但是下层仍然是TCP，因为TCP的重传机制，只要一个包丢失就得判断丢包并且重传，导致发生队头阻塞的问题，但是UDP没有这个限制。除此之外，它还有如下特点：

实现了自己的加密协议，通过类似TCP的TFO机制实现0-RTT，当然TLS1.3已经实现了0-RTT。
支持重传和纠错机制，在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包。

纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包的异或值包算出丢失包。
在丢失两个包及以上的情况就是用重传机制，因为算不出来了。





## HTTP报文详解

```http
GET /article/12 HTTP/1.1
Host: www.xxx.cn
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: SESSION=so9nlsvenminor5abs65sh9dsa
                                                     //这是一个空行
HTTP/1.1 200 OK
Server: nginx
Date: Sun, 17 May 2020 17:04:29 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Vary: Accept-Encoding
X-Powered-By: blade-2.0.6-BETA
Content-Encoding: gzip
```





<font color="#dd0000">请求报文</font>

![requestbaowen](https://i.loli.net/2020/07/07/PecNlShR8CU3jK1.png)





请求报文通常由三部分组成：

起始行：描述请求或者响应的基本信息

头部字段集合：key-value形式说明报文

消息正文：实际传输诸如图片等信息。具体如下图试试

![method](https://i.loli.net/2020/07/07/hjVUGHw1oTLBsct.png)



说一下非常常见的几种请求方法

Get：从服务器中取资源。可以请求图片，视频等

HEAD:和Get类似，但是从服务器请求的资源不会返回请求的实体数据，只会返回响应头

POST/PUT：对应于GET，向服务器发送数据





<font color="#dd0000">响应报文</font>

![response](https://i.loli.net/2020/07/07/VwQUjdIBCYvE6qg.png)



状态行----服务器响应的状态

<1> 版本号：使用的HTTP什么版本

<2> 状态码：不同数字代表不同的结果，就如我们在编码时，通过返回不同的值代表不同的语义。



<font color="#dd0000">状态码一共分为5类</font>

> 1××：处于中间状态，还需后续操作
>
> 2××：成功收到报文并正确处理

"200 OK"

最常见的成功状态码，表示一切正常，客户端获得期许的处理结果。如果不是Head请求，那么在响应头中通常会有body数据。

"204 No Content"

这个的含义和"200"很相似，不同之处在于它的响应头中没有body数据。

"206 Partial Content"

是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/5000”，意思是此次获取的是总计 5000 个字节的前 100 个字节。

> 3××：重定向到其他资源位置

"301 Moved Permanently"

“永久重定向”，意思是本地请求的资源以及不存在，使用新的URI再次访问。

“302 Found”

“Moved Temporarily”，“临时重定向”，临时则所请求的资源暂时还在，但是目前需要用另一个URI访问。

301 和 302 通过在字段Location中表明需要跳转的URI。两者最大的不同在于一个是临时改变，一个是永久改变。举个例子，有时候需要将网站全部升级为HTTPS，这种永久性改变就需要配置永久的"301"。有时候晚上更新系统，系统暂时不可用，可以配置"302"临时访问，此时不会做缓存优化，第二天还会访问原来的地址。

“304 Not Modified”

运用于缓存控制。它用于 If-Modified-Since 等条件请求，表示资源未修改，可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。

> 4××：请求报文有误，服务器无法处理

"400 Bad Request”

通用错误码，表示请求报文有错误，但是这个错误过于笼统。不知道是客户端还是哪里的错误，所以在实际应用中，通常会返回含有明确含义的状态码。

“403 Forbidden”

注意了，这一个是表示服务器禁止访问资源。原因比如涉及到敏感词汇、法律禁止等。当然，如果能让客户端有一个清晰的认识，可以考虑说明拒绝的原因并返回即可。

“404 Not Found”

这可能是我们都知道且都不想看到的状态码之一，它的本意是想要的资源在本地未找到从而无法提供给服务端，但是现在，只要服务器"耍脾气"就会给你返回 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，

"405 Method Not Allowed"

获取资源的方法好几种，我们可以对某些方法进行限制。例如不允许 POST 只能 GET；

"406 Not Acceptable"

客户端资源无法满足客户端请求的条件，例如请求需要中文但只有英文；

"408 Request Timeout"

请求超时，服务器等待了过长的时间；

"409 Conflict"：

多个请求发生了冲突，可以理解为多线程并发时的竞态；

413 Request Entity Too Large：

请求报文里的 body 太大；

414 Request-URI Too Long：请求行里的 URI 太大；

429 Too Many Requests：客户端发送了太多的请求，
通常是由于服务器的限连策略；

431 Request Header Fields Too Large：请求头某个字
段或总体太大；

> 5××：服务器错误，服务器对请求出的时候发生内部错误。

“500 Internal Server Error”

和400 类似，属于一个通用的错误码，但是服务器到底是什么错误我们不得而知。其实这是好事，尽量少的将服务器资源暴露外网，尽量保证服务器的安全。

“502 Bad Gateway”

通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。

“503 Service Unavailable”

表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。

503 是一个“临时”的状态，

暂时比较忙，稍后提供服务。在响应报文中的“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。





<font color="#dd2">Body</font>

> 上面大部分都是涉及到header部分，还有非常重要的body，everybody

头字段注意事项

<1> 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；

<2> 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线"_"。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；

<3> 字段名后面必须紧接着“:”，不能有空格，而":"后的字段值前可以有多个空格；

<4> 字段的顺序是没有意义的，可以任意排列不影响语义；

<5> 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。

HTTP的body常常被分为这几种的类别

<1> text:超文本text/html,纯文本text/plain

<2> audio/video:音视频数据

<3> application: 可能是文本，也可能是二进制，交给上层应用处理

<4> image: 图像文件。image/png等

但是带宽一定，数据大了通常考虑使用压缩算法进行压缩，在HTTP中使用Encoding type表示，常用的压缩方式有下面几种

<1> gzip:

> 一种数据格式，默认且目前仅使用deflate算法压缩data部分

<2> deflate:

> deflate是一种压缩算法，是huffman编码的一种加强

<3> br:

> br通过变种的LZ77算法、Huffman编码以及二阶文本建模等方式进行数据压缩，其他压缩算法相比，它有着更高的压塑压缩效率

使用相应的压缩方法在带宽一定的情况下确实有不错的效果，但是gzip等主要针对文件压缩效果不错，但是对视频就不行了。这个时候是不是可以使用数据结构中常用的分而治之，大化小再合并的方式呢，ok，在报文中使用"Transer-Encoding:chunked"表示，代表body部分数据是分块传输的。另外在body中存在一个content-length字段表示body的长度，两者不能共存，另外很多时候是流式数据，body中没有指明content-length，这个时候一般就是chunked传输了。

现在可以通过采用分块的方式增强带宽的利用率，那他的编码规则如何呢

<1> 每一个分块包含长度和数据块

<2> 长度头按照CRLF结束

<3> 数据块在长度快后，且最后CRLF结尾

<4> 使用长度0表示结束，"0\r\n\r\n"

分块解决了咋们一部分问题，但是有的时候我们想截断发送怎么办呢。在HTTP中提供了使用字段“Accept - Ranges: bytes”，明确告知客户端：“我是支持范围请求的”。那么Range范围是怎样的呢，Range从0开始计算，比如Range:0-5则读取前6个字节，服务器收到了这个请求，将如何回应呢

<1> 合法性检查。比如一共只有20字节，但是请求range：100-200。此时会返回416----"范围请求有误"

<2> 范围正常，则返回216，表示请求数据知识一部分

<3> 服务器端在相应投资端增加Content-Range,格式"bytes x-y/length"。





<font color="#dd2">Cookie机制</font>

HTTP是无状态、无记忆的，Cookie机制的出现让其有记忆功能，是怎么个实现呢

![cookie](https://i.loli.net/2020/07/07/UBTs71PnvzMLlj8.png)



从上图我们可以知道Cookie是由浏览器负责存储，并不是操作系统负责，我们换个浏览器打开同样的网页，服务就认不出来了。

Cookie常见的应用一个是身份识别，一个是广告追踪，比如我们在访问网页视频或者图片的时候，广告商会悄悄给我们Cookie打上标记，方便做关联分析和行为分析，从而给我推荐一些相关内容。





## HTTPS

好人占多数，坏人也不少。总有些要搞坏事，因为HTTP是明文，所以需要想办法保护明文，从而出现了https。

![](https://i.loli.net/2020/07/07/EXxj2epuQV6f9NK.png)

从上图我们知道HTTPS无非是在传输层和应用层中间加了一层TLS，正是TLS紧跟当代密码学的步伐，尽全力的保障用户的安全。

TLS由SSL握手协议，SSL修改密码规范协议，SSL警报协议，SSL记录协议组成。



![](https://i.loli.net/2020/07/07/GAtWOIuia1V2oHC.png)



SSL握手协议：

> 相对于三次握手

记录协议

> 记录为TLS发送接收数据的基本单位。它的自协议需要通过记录协议发出。如果多个纪录数据则可以一个TCP包一次性发出。

警报协议

> 类似HTTP状态码，通过反馈不同的消息进行不同的策略。

变更密码规范协议

> 告诉对方，从此刻开始，后续的数据将使用加密算法进行加密再传输。







<font color="#dd2">对称加密与非对称加密</font>



<font color="#dd001">对称加密</font>

对称加密，顾名思义，加密方与解密方使用同一钥匙(秘钥)。具体一些就是，发送方通过使用相应的加密算法和秘钥，对将要发送的信息进行加密；对于接收方而言，使用解密算法和相同的秘钥解锁信息，从而有能力阅读信息。

![](https://i.loli.net/2020/07/07/pYUQK1ghfyAatvb.png)

<font color="#dd001">非对称加密</font>

在对称加密中，发送方与接收方使用相同的秘钥。那么在非对称加密中则是发送方与接收方使用的不同的秘钥。其主要解决的问题是防止在秘钥协商的过程中发生泄漏。比如在对称加密中，小蓝将需要发送的消息加密，然后告诉你密码是123balala,ok,对于其他人而言，很容易就能劫持到密码是123balala。那么在非对称的情况下，小蓝告诉所有人密码是123balala,对于中间人而言，拿到也没用，因为没有私钥。所以，非对称密钥其实主要解决了密钥分发的难题。如下图

![](https://i.loli.net/2020/07/07/Q5cWVRSznFd97fU.png)

HTTPS请求建立连接过程

![](https://i.loli.net/2020/07/07/p3zasZCMKHuFlXS.png)







### HTTP特点小结

1：灵活且易扩展，他的头部字段很多都是可定制且可扩展

2：应用广泛。各个领域都有涉及。"跨平台，跨语言"

3：无状态。没有记忆功能，少功能即少占用资源。另外无状态更容易搭建集群，通过负载均衡将请求转发到任意一台服务器。缺点是无法支持需要连续步骤的"事务"操作。我们知道TCP协议有11种状态，不同状态代表通信过程中不同的含义。同样操作系统中的进程也有执行，就绪，活动阻塞等多种状态。但是HTTP全程都是"懵逼"无状态。比如小华请求服务器获取视频X，服务器觉得可行就发给小华。小华还想获取视频Y，这时服务器不会记录之前的状态，也就不知道这两个请求是否是同一个，所以小华还得告诉服务器自己的身份。

4：明文。优点是能让开发人员通过wireshark工具更直观的调试。缺点即裸奔互联网，没隐私可言。

5:可靠传输。HTTP为应用层协议，基于TCP/IP，而TCP为“可靠”传输协议，因此HTTP能在请求应答中"可靠"传输数据。

6：应用层协议。应用层协议很多，其中常用的邮件协议SMTP，上传下载文件ftp，默认端口22/23，SSH远程登录(XSHELL)。这些应用层协议都太专一，而HTTP通过各种头部字段，实体数据的组合，并综合缓存代理等功能，不得不说是网络中的冠希哥。



[1]作者：Miyang
链接：https://segmentfault.com/a/1190000016656529?utm_source=tag-newest
来源：SegmentFault 思否
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。













### 面试常见问题

- Get和Post区别

  GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）,GET方法的报文主体没有任何语义。

  POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。

- HTTP与HTTPS区别

      1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。  
      2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。
      3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
      4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

- HTTP通信过程

  ```
  1 浏览器根据域名解析IP地址
  2 浏览器与WEB服务器建立一个TCP连接
  3 浏览器给WEB服务器发送一个HTTP请求
  4 服务器端响应HTTP请求，浏览器得到HTML代码
  5 浏览器解析HTML代码，并请求HTML代码中的资源
  6 关闭TCP连接，浏览器对页面进行渲染呈现给用户
  ```

- 浏览器输入一个地址。到页面展示中间经历了哪些步骤？

  ```
  1、DNS解析
  2、TCP连接
  3、发送HTTP请求
  4、服务器处理请求并且返回HTTP报文
  5、浏览器解析并且渲染页面
  6、连接结束
  ```

- cookies机制和session机制的区别：

  [https://github.com/Cjpro/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/session%E5%92%8Ccookie.md](https://github.com/Cjpro/fucking-algorithm/blob/master/技术/session和cookie.md)

- HTTP请求报文与响应报文格式

- 一次完整的HTTP请求所经历的7个步骤

  ```
  1. 建立TCP连接
  在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。
  
  2. Web浏览器向Web服务器发送请求命令
  一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。
  
  3. Web浏览器发送请求头信息
  浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。
  
  4. Web服务器应答
  客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。
  
  5. Web服务器发送应答头信息
  正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。
  
  6. Web服务器向浏览器发送数据
  Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。
  
  7. Web服务器关闭TCP连接
  一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive
  
  TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。
  ```

  

- 不同版本的HTTP区别

- HTTP优点缺点

- URI和URL的区别

- 如何判断是否为http

- HTTP 1.1引入分块传输编码提供了以下几点好处

- 长连接与短连接的区别，以及应用场景

- 常见web攻击

- 站内跳转和外部重定向有何区别

- HTTP的keep-alive是干什么的？

- 关于Http 2.0 你知道多少？

- 讲讲304缓存的原理

- HTTP与RPC异同

